# 不修改载体的图片信息隐藏与加密在线聊天系统

本项目是 **2025-2026 学年西安交通大学密码学期末大作业**，学号3125357028，设计并实现了一个 **不修改载体** 的图片信息隐藏与加密系统，整体方案为 **纯原创**，应该全网独一份。

**使用方式：** **直接执行app.py然后本地打开[127.0.0.1:5001/]就行了，每打开一个就是一个用户进入了聊天室，只能加密英文和空格逗号和句号。**

**如果想知道原理，大概思路就是：
一张图片-【基于图片特征进行的hash算法,不使用密钥】->32位二进制->【SHA-256哈希算法，使用密钥】->新32位二进制-【%29】->代表一个字符（空格/逗号/句号/26个字母）**
**因此也就是说一个图片唯一对应一个字母，但是一个字母可能对应多个图片（而且存在密钥）所以加密解密系统就完成了：加解密都是正向运算，系统中自带图片，加密时把全部图片代表什么字母算出来然后随机选择一张图片，解密时直接对某张图片运算。**

**剩下的是gpt自己写的看看得了**







系统将图片本身视为“密码本”，通过对图片内容做特征提取和带密钥哈希，将 **26 个英文字母 + 空格 + 逗号 + 句号（共 29 个符号）** 映射到图片集合上，实现：

- **信息隐藏**：聊天界面中只看到一串“普通图片”，看起来像在发图，而不是在发密文；
- **加密保护**：每一张图片在给定密钥下对应一个字符，但同一个字符可以对应多张不同的图片；
- **不改载体**：图片本身完全不被修改，系统只是选择和组合已有图片，因此任何基于“检测图片被篡改/嵌入”的传统隐写分析，对本系统都是无效的。

攻击者即使拿到所有传输的图片，也很难从图片内容里直接看出其中包含了文本信息，更无法通过“分析图片被修改的痕迹”来破译密钥或还原明文——因为整个系统从头到尾都**不改动图片内容**。

---

## 整体思路与作用

- **图片 → 32 位二进制指纹（无密钥）**
  - 使用 `image_to_binary.py` 中的算法，对任意一张图片通过 SIFT 特征提取与象限映射，得到一串 **32 位二进制字符串**，相当于一个没有密钥的“认证码/指纹”。
- **带密钥的哈希映射**
  - 在 32 位二进制的基础上，引入密钥，使用哈希（SHA-256 截断）+ 取模：
    - \((\text{key} \parallel \text{binary32}) \xrightarrow{\text{SHA-256}} \text{int} \bmod 29\)
    - 结果为 `0-28`：
      - `0-25` → `A-Z`
      - `26` → 空格
      - `27` → 逗号
      - `28` → 句号
  - 这样就建立起 **“图片 → 字符（带密钥）”** 的映射。
- **一图一字，多图同字**
  - 在给定密钥下：
    - 每张图片通过上述流程会落在 `0-28` 里的某一个下标上，对应一个符号（字符）。
    - 同一个字符一般会对应多张不同的图片，系统会在这些图片里尽量随机且不重复地选择，从而：
      - 提高表面多样性（看起来像正常发图）；
      - 降低统计特征被学到的可能性。
- **加解密都是“正向运算”**
  - 加密：给定明文字符序列和密钥，系统从载体图片库中选出一串图片作为密文载体。
  - 解密：给定密钥和这串图片，重新跑一次“图片 → 32位指纹 → 带密钥哈希 → 取模”的正向流程，直接还原出字符序列。
  - 整个过程没有传统意义上的“逆运算”，都是“同一套正向运算”，但由密钥决定输出空间的切分方式。

**总结：**

- 作用一：**让人不容易察觉“这里在传密文”**——表面只是一堆看似普通的图片。
- 作用二：**提供带密钥的访问控制**——不知道正确密钥的人即使拥有所有图片和算法，也无法把图片序列稳定地还原成有意义的文本。
- 作用三：**不修改载体**——避免了传统隐写中“在载体中嵌入信息”的各种可检测痕迹，从信息隐藏和密码学两个角度提高安全性。

---

## 技术实现（特征提取与 32 位指纹）**！！！！！！关键技术！！！！！！**

以下内容对应原始的 `image_to_binary.py` 功能，用于为每张图片生成 32 位指纹。

1. **图片分块处理**：将每张图片分成 4×4 共 16 块
2. **SIFT 特征提取**：对每一块提取 SIFT 特征点（有大小和方向）
3. **特征筛选**：使用阈值筛选掉小的特征点
4. **象限映射**：根据特征向量的方向映射到象限，生成 2 位二进制
   - 第一象限（0-90 度）→ 00
   - 第二象限（90-180 度）→ 01
   - 第三象限（180-270 度）→ 10
   - 第四象限（270-360 度）→ 11
5. **32 位二进制生成**：16 块 × 2 位 = 32 位二进制字符串
6. **可视化**：生成处理后的图片，显示特征点、大小圆和方向线
7. **CSV 记录**：保存图片名和 32 位二进制的对应关系

这些技术细节既可以单独用作“图片指纹提取工具”，也作为上层加密/隐藏系统的基础模块。

---

## 安装依赖

```bash
pip install -r requirements.txt
```

## 使用方法（指纹提取模块）

1. **准备图片数据**：
   - 在项目根目录下创建 `RawImg` 文件夹
   - 将520张图片放入该文件夹（支持多种格式：.jpg, .jpeg, .png, .bmp）
   - 程序会自动按文件名排序，并将输出重命名为 `0000.jpg` 到 `0519.jpg`

2. **运行程序**：
   ```bash
   python image_to_binary.py
   ```

3. **输出结果**：
   - `ProcessedImg/` 文件夹：包含处理后的图片（0000.jpg到0519.jpg），显示特征点和方向
   - `image_binary_mapping.csv`：CSV文件，记录每张图片对应的32位二进制编码

## 文件结构（指纹提取相关）

```
encryption/
├── image_to_binary.py          # 主程序文件
├── requirements.txt            # 依赖包列表
├── README.md                   # 说明文档
├── RawImg/                     # 输入图片文件夹（需要手动创建并放入图片）
│   ├── 0000.jpg
│   ├── 0001.jpg
│   └── ...
├── ProcessedImg/               # 输出图片文件夹（自动生成）
│   ├── 0000.jpg
│   ├── 0001.jpg
│   └── ...
└── image_binary_mapping.csv    # 映射关系CSV文件（自动生成）
```

## CSV文件格式

CSV文件包含两列：
- `image_name`: 图片文件名（如 0000.jpg）
- `binary_code`: 对应的32位二进制字符串（如 000110011001...）

## 参数说明

可以在 `if __name__ == "__main__":` 代码块中调整以下参数：
- `threshold`: SIFT特征点大小阈值（默认10.0），小于此值的特征点会被筛选掉
- `input_dir`: 输入图片目录（默认"RawImg"）
- `output_dir`: 输出图片目录（默认"ProcessedImg"）
- `csv_file`: CSV文件名（默认"image_binary_mapping.csv"）

## 注意事项

- 需要安装OpenCV（opencv-python）和NumPy
- 图片格式支持：.jpg, .jpeg, .png, .bmp
- 如果某张图片无法读取或处理失败，程序会跳过该图片并继续处理下一张
- ImageNet数据下载功能需要API访问权限，如果无法使用，请手动准备图片数据
